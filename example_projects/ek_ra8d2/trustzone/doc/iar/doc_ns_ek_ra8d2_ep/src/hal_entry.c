/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2025 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "common_utils.h"

/*******************************************************************************************************************//**
 * @addtogroup DOC_NS_EP
 * @{
 **********************************************************************************************************************/
/** Macros **/
/* To write the first data to doc register for subtraction event */
#define DOC_DATA_SUB                 (0xA5A4)
/* To write the second data to doc register for subtraction event */
#define DOC_DATA_UNDERFLOW           (0x0002)
/* To write the first data to doc register for addition event */
#define DOC_DATA_ADD                 (0X5A5A)
/* To write the second data to doc register for addition event to overflow */
#define DOC_DATA_OVERFLOW            (0x0001)
/* To write the data to doc register for comparison match event */
#define DOC_DATA_COMPARISON_MATCH    (0xA5A5)
/* To write the data to doc register for comparison mismatch event */
#define DOC_DATA_COMPARISON_MISMATCH (0xB5B5)

static void doc_deinit(void);

/** Global variables **/
static bool b_doc_event_flag = false;           /* Event counter updates for every callback triggers */
extern bsp_leds_t g_bsp_leds;                   /* LED Structure used to blink on board LED */

/* The 2 following prototypes for custom guard function can be removed in future */
fsp_err_t led_set_guard(bsp_io_port_pin_t pin, bsp_io_level_t level);
doc_event_t doc_cfg_event_read_guard(void);

doc_callback_args_t g_doc_callback_args;
void doc_callback(doc_callback_args_t *p_args);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_pack_version_t version = {RESET_VALUE};
    fsp_err_t err              = FSP_SUCCESS;
    /* Version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major,\
              version.version_id_b.minor, version.version_id_b.patch);

    APP_PRINT("\r\nThe example project demonstrates the typical use of the DOC HAL module APIs."
              "\r\nThe project performs the different event operations selected by the user in"
              "\r\nconfigurator properties. Events can be selected viz., Compare Match, Compare Mismatch,"
              "\r\nAddition Overflow, Subtraction Underflow. Upon Success/Failure of operation,"
              "\r\nthe result will be displayed on RTT Viewer. LED will turn ON only if the selected"
              "\r\nevent operation is success and stays OFF if the operation fails.\r\n");

    /* Initialize the DOC module for Comparison/Addition/Subtraction Operations with Initial
     * value written in DOC Data Setting Register
     * Note:
     *     Arguments are passed in as NULL since the guard functions will ignore them.
     *     The guard functions are generated in the secure project doc_s_ek_ra8m2_ep/src/g_doc_guard.c */
    err = g_doc_open_guard(NULL, NULL);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** g_doc_open_guard failed **");
        APP_ERR_TRAP(err);
    }

    err = g_doc_callback_set_guard(NULL, doc_callback, NULL, &g_doc_callback_args);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** g_doc_callback_set_guard failed **");
        APP_ERR_TRAP(err);
    }

    /* Write the predefined data to doc register, depends on the selected event operations will take place */
    switch (doc_cfg_event_read_guard())
    {
        case DOC_EVENT_COMPARISON_MISMATCH:
            APP_PRINT("\r\nSelected event is Comparison MisMatch");
            /* Write mismatch to the DOC Data Input Register */
            err = g_doc_write_guard(NULL, DOC_DATA_COMPARISON_MISMATCH);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_COMPARISON_MATCH:
            APP_PRINT("\r\nSelected event is Comparison Match");
            /* Write match data to the DOC Data Input Register */
            err = g_doc_write_guard(NULL, DOC_DATA_COMPARISON_MATCH);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_ADDITION:
            APP_PRINT("\r\nSelected event is Addition Overflow");
            /* Write first data to the DOC Data Input Register */
            err = g_doc_write_guard(NULL, DOC_DATA_ADD);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            /* Write second data to the DOC Data Input Register to occur overflow event */
            err = g_doc_write_guard(NULL, DOC_DATA_OVERFLOW);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_SUBTRACTION:
            APP_PRINT("\r\nSelected event is Subtraction Underflow");
            /* Write first data to the DOC Data Input Register */
            err = g_doc_write_guard(NULL, DOC_DATA_SUB);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            /* Write second data to the DOC Data Input Register to occur underflow event */
            err = g_doc_write_guard(NULL, DOC_DATA_UNDERFLOW);
            /* Handle error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            break;
        default:
            break;
    }

     /* Prints the RTT message when interrupt occurs upon successful event operations */
    if (true == b_doc_event_flag)
    {
        b_doc_event_flag = false;   /* Reset flag */
        APP_PRINT("\r\nDOC operation is successful for the selected event");
        /* Turn ON LED to indicate callback triggered, along with output on RTT */
#if defined (BOARD_RA8T1_MCK) || defined (BOARD_RA8T2_MCK)
        led_set_guard((bsp_io_port_pin_t)g_bsp_leds.p_leds[0], BSP_IO_LEVEL_LOW);
#else
        led_set_guard((bsp_io_port_pin_t)g_bsp_leds.p_leds[0], BSP_IO_LEVEL_HIGH);
#endif
    }
    else
    {
        APP_PRINT("\r\nDOC operation failed for the selected event");
    }
    APP_PRINT("\r\nRestart the application to rerun the code");
    while (true)
    {
        ; /* Do nothing */
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief       Based on the selected event in the configurator. The doc call back will occur for the selected
 *              event when operations are performed with the reference data.
 * @param[in]   p_args
 * @return      None
 **********************************************************************************************************************/
void doc_callback(doc_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    /* Set the event flag */
    b_doc_event_flag = true;
}

/*******************************************************************************************************************//**
 * @brief       This function is used to deinitialize the DOC module.
 * @param[in]   None
 * @return      None
 **********************************************************************************************************************/
static void doc_deinit(void)
{
    fsp_err_t err = FSP_SUCCESS;
    err = g_doc_close_guard(NULL);
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** g_doc_close_guard failed **");
        APP_ERR_TRAP(err);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 * @} (end defgroup DOC_NS_EP)
 **********************************************************************************************************************/
