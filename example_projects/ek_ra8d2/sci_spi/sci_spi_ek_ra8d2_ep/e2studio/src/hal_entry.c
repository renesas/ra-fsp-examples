/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * Copyright (c) 2020 - 2025 Renesas Electronics Corporation and/or its affiliates
 *
 * SPDX-License-Identifier: BSD-3-Clause
 **********************************************************************************************************************/

#include "common_utils.h"

/*******************************************************************************************************************//**
 * @addtogroup sci_spi_ep
 * @{
 **********************************************************************************************************************/

/* Slave Select pin for all boards to enable data transfer */
#if defined (BOARD_RA6M2_EK) || defined (BOARD_RA6M1_EK) || defined (BOARD_RA4M1_EK) || defined (BOARD_RA6T1_RSSK) ||\
    defined (BOARD_RA2L1_EK) || defined (BOARD_RA4W1_EK) || defined (BOARD_RA2E2_EK) || defined (BOARD_RA2E3_FPB)  ||\
    defined (BOARD_RA4E1_FPB) || defined (BOARD_RA2L2_EK) || defined (BOARD_RA2T1_FPB)
#define CS_PIN  (BSP_IO_PORT_01_PIN_03)
#elif defined (BOARD_RA6M3_EK) || defined (BOARD_RA6M3G_EK)
#define CS_PIN  (BSP_IO_PORT_02_PIN_05)
#elif defined (BOARD_RA2A1_EK)
#define CS_PIN  (BSP_IO_PORT_04_PIN_10)
#elif defined (BOARD_RA2E1_EK)
#define CS_PIN  (BSP_IO_PORT_04_PIN_03)
#elif defined (BOARD_RA4E2_EK) || defined (BOARD_RA6E2_EK) || defined (BOARD_RA6T3_MCK) || defined (BOARD_RA4T1_MCK)
#define CS_PIN  (BSP_IO_PORT_03_PIN_01)
#elif defined (BOARD_RA6T2_MCK)
#define CS_PIN  (BSP_IO_PORT_10_PIN_12)
#elif defined (BOARD_RA8M1_EK) || defined (BOARD_RA8D1_EK)
#define CS_PIN  (BSP_IO_PORT_10_PIN_05)
#elif defined (BOARD_RA8T1_MCK) || defined (BOARD_RA8P1_EK) || defined (BOARD_RA8D2_EK)
#define CS_PIN  (BSP_IO_PORT_06_PIN_04)
#elif defined (BOARD_RA2A2_EK)
#define CS_PIN  (BSP_IO_PORT_05_PIN_03)
#elif defined (BOARD_RA8E1_FPB)
#define CS_PIN  (BSP_IO_PORT_08_PIN_04)
#elif defined (BOARD_RA4L1_EK) || defined (BOARD_RA4C1_EK)
#define CS_PIN  (BSP_IO_PORT_01_PIN_12)
#elif defined (BOARD_RA8E2_EK)
#define CS_PIN  (BSP_IO_PORT_03_PIN_14)
#elif defined (BOARD_RA8T2_MCK)
#define CS_PIN  (BSP_IO_PORT_07_PIN_10)
#else
#define CS_PIN  (BSP_IO_PORT_04_PIN_13)
#endif

/* Function macros to assert and de-assert Slave Select pins */
#define CS_ASSERT(x)        (R_IOPORT_PinWrite(&g_ioport_ctrl, (x), BSP_IO_LEVEL_HIGH))
#define CS_DE_ASSERT(x)     (R_IOPORT_PinWrite(&g_ioport_ctrl, (x), BSP_IO_LEVEL_LOW))

#define EP_INFO             "\r\nThis example project demonstrates the basic usage of SCI_SPI driver."\
                            "\r\nThe project writes commands to the slave sensor and reads the temperature"\
                            "\r\nvalue using SCI_SPI bus configured as master. The temperature values are"\
                            "\r\ncontinuously printed on J-Link RTT Viewer.\r\n"

#define CONVERSION_TIME     (200U)  /* Conversion time for 12-bit resolution */
#define PRINT_DELAY         (2U)    /* Delay for RTT Viewer prints */

static volatile spi_event_t g_master_event_flag;    /* Master transfer event completion flag */
static volatile int32_t g_wait_count = INT32_MAX;   /* Wait counter for wait operation monitoring */

static uint8_t read_temperature_reg[3] = {0x01};           /* Read register address of temperature sensor */
static uint8_t temperature_values[3]   = {RESET_VALUE};    /* Variable to store read temperature values */
uint8_t config_read[2] = {0x00};
static char dataBuff[30];

/* Function to check occurrence of event after data transfer */
static void sci_spi_event_check(void);
/* Cleanup function for opened module */
static void sci_spi_deinit(void);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};
    float temperature = RESET_VALUE;

    /* Value for configuration register write. Set resolution as 12 bits */
    const uint8_t config_sensor[3] =
    {
     0x80, 0x06
    };

    /* Version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example project information printed on the Console */
    APP_PRINT(BANNER_1);
    APP_PRINT(BANNER_2);
    APP_PRINT(BANNER_3, EP_VERSION);
    APP_PRINT(BANNER_4, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(BANNER_5);
    APP_PRINT(BANNER_6);
    APP_PRINT(EP_INFO);

    /* Initialize SCI_SPI channel as Master */
#if (BSP_PERIPHERAL_SCI_B_PRESENT)
    err = R_SCI_B_SPI_Open(&g_spi_ctrl, &g_spi_cfg);
#else
    err = R_SCI_SPI_Open(&g_spi_ctrl, &g_spi_cfg);
#endif /* BSP_PERIPHERAL_SCI_B_PRESENT */
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n**R_"SCI_TYPE"_SPI_Open API failed**\r\n");
        APP_ERR_TRAP(err);
    }

    /* Assert Slave select pin to start data transfer */
    CS_ASSERT(CS_PIN);

    /* Configure temperature sensor */
#if (BSP_PERIPHERAL_SCI_B_PRESENT)
    err = R_SCI_B_SPI_Write(&g_spi_ctrl, &config_sensor[0], sizeof(config_sensor), SPI_BIT_WIDTH_8_BITS);
#else
    err = R_SCI_SPI_Write(&g_spi_ctrl, &config_sensor[0], sizeof(config_sensor), SPI_BIT_WIDTH_8_BITS);
#endif /* BSP_PERIPHERAL_SCI_B_PRESENT */
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        sci_spi_deinit();
        APP_ERR_PRINT("\r\n**R_"SCI_TYPE"_SPI_Write API failed**\r\n");
        APP_ERR_TRAP(err);
    }

    /* Check for transfer complete event and handle error in the case of event failure */
    sci_spi_event_check();

    /* De-assert Slave select pin to stop data transfer */
    CS_DE_ASSERT(CS_PIN);

    /* Resetting SPI Master event flag */
    g_master_event_flag = RESET_VALUE;

    /* Assert Slave select pin to start data transfer */
    CS_ASSERT(CS_PIN);

    /* Read configured temperature sensor */
#if (BSP_PERIPHERAL_SCI_B_PRESENT)
    err = R_SCI_B_SPI_Read(&g_spi_ctrl, &config_read[0], sizeof(config_read), SPI_BIT_WIDTH_8_BITS);
#else
    err = R_SCI_SPI_Read(&g_spi_ctrl, &config_read[0], sizeof(config_read), SPI_BIT_WIDTH_8_BITS);
#endif /* BSP_PERIPHERAL_SCI_B_PRESENT */
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        sci_spi_deinit();
        APP_ERR_PRINT("\r\n**R_"SCI_TYPE"_SPI_Read API failed**\r\n");
        APP_ERR_TRAP(err);
    }

    /* Check for transfer complete event and handle error in the case of event failure */
    sci_spi_event_check();

    /* De-assert Slave select pin to stop data transfer */
    CS_DE_ASSERT(CS_PIN);

    /* Check if sensor is configured as expected */
    if (config_sensor[1] != config_read[1])
    {
        /* Incorrect configuration of temperature sensor */
        err = FSP_ERR_INVALID_HW_CONDITION;
        APP_ERR_TRAP(err);
    }

    /* Adding conversion time as 200ms for the configured 12-bit resolution,
     * before asserting CS_PIN for reading the temperature values in a loop */
    R_BSP_SoftwareDelay(CONVERSION_TIME, BSP_DELAY_UNITS_MILLISECONDS);

    while (true)
    {
        /* Resetting SPI Master event flag */
        g_master_event_flag = RESET_VALUE;

        memset(dataBuff, RESET_VALUE, sizeof(dataBuff));

        /* Assert Slave select pin to start data transfer */
        CS_ASSERT(CS_PIN);
        /* Read the temperature */
#if (BSP_PERIPHERAL_SCI_B_PRESENT)
        err = R_SCI_B_SPI_WriteRead(&g_spi_ctrl, read_temperature_reg, temperature_values, sizeof(temperature_values),\
                                    SPI_BIT_WIDTH_8_BITS);
#else
        err = R_SCI_SPI_WriteRead(&g_spi_ctrl, read_temperature_reg, temperature_values, sizeof(temperature_values),\
                                  SPI_BIT_WIDTH_8_BITS);
#endif /* BSP_PERIPHERAL_SCI_B_PRESENT */
        /* Handle error */
        if (FSP_SUCCESS != err)
        {
            sci_spi_deinit();
            APP_ERR_PRINT("\r\n**R_"SCI_TYPE"_SPI_WriteRead API failed**\r\n");
            APP_ERR_TRAP(err);
        }

        /* Check for transfer complete event and handle error in the case of event failure */
        sci_spi_event_check();

        /* De-assert Slave select pin to stop data transfer */
        CS_DE_ASSERT(CS_PIN);

        /* Manipulating the read temperature values to print for users */
        temperature = (float) ((int32_t)( ((uint32_t) temperature_values[2] << 4) | \
                      ((uint32_t) temperature_values[1] >> 4) )) / 16.0f;
        /* Function to print float values */
        snprintf(dataBuff, sizeof(dataBuff), "%f", temperature);
        APP_PRINT("\r\nTemperature:  %s *C", dataBuff);

        /* Delay to display temperature values on RTT Viewer */
        R_BSP_SoftwareDelay(PRINT_DELAY, BSP_DELAY_UNITS_SECONDS);
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief       This function checks occurrence of data transfer complete event until timeout occurs and handles errors.
 * @param[IN]   None
 * @retval      None
 **********************************************************************************************************************/
static void sci_spi_event_check(void)
{
    while (SPI_EVENT_TRANSFER_COMPLETE != g_master_event_flag)
    {
        g_wait_count--;
        if (RESET_VALUE >= g_wait_count)
        {
            sci_spi_deinit();
            APP_ERR_PRINT("\r\nSPI module blocked in Write/Read operation.\r\n");
            /* Return time out error if SPI operation fails to complete */
            APP_ERR_TRAP(FSP_ERR_TIMEOUT);
        }
        /* All other error events are handled here */
        else if (SPI_EVENT_TRANSFER_ABORTED == g_master_event_flag)
        {
            sci_spi_deinit();
            APP_ERR_PRINT("\r\nSPI module transfer aborted.\r\n");
            APP_ERR_TRAP(FSP_ERR_TRANSFER_ABORTED);
        }
        else
        {
            /* Do nothing */
        }
    }
}

/*******************************************************************************************************************//**
 * @brief       This function closes opened SCI_SPI module before the project ends up in an error trap.
 * @param[IN]   None
 * @retval      None
 **********************************************************************************************************************/
static void sci_spi_deinit(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Close SCI_SPI module */
#if (BSP_PERIPHERAL_SCI_B_PRESENT)
    err = R_SCI_B_SPI_Close(&g_spi_ctrl);
#else
    err = R_SCI_SPI_Close(&g_spi_ctrl);
#endif /* BSP_PERIPHERAL_SCI_B_PRESENT */
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* SPI close failure message */
        APP_ERR_PRINT("\r\n**R_"SCI_TYPE"_SPI_Close API failed**\r\n");
    }
}

/*******************************************************************************************************************//**
 * @brief       SCI_SPI Master callback function.
 * @param[in]   p_args
 * @retval      None
 **********************************************************************************************************************/
void sci_spi_callback(spi_callback_args_t *p_args)
{
    if (SPI_EVENT_TRANSFER_COMPLETE == p_args->event)
    {
        g_master_event_flag = SPI_EVENT_TRANSFER_COMPLETE;
    }
    else
    {
        /* Updating the flag here to capture and handle all other error events */
        g_master_event_flag = SPI_EVENT_TRANSFER_ABORTED;
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 * @} (end addtogroup sci_spi_ep)
 **********************************************************************************************************************/
