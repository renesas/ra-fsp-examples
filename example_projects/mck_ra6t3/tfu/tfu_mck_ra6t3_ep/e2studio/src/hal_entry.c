/***********************************************************************************************************************
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/
#include "hal_data.h"
#include "common_utils.h"
#include "tfu_ep.h"
#include <string.h>
#include "math.h"

/* Arrays to store cos and sine values for input to atan2f and hypotf */
float sine_arr[RES_MAX_VAL] = {0};
float cos_arr[RES_MAX_VAL] = {0};
float atan_arr[RES_MAX_VAL] = {0};
float hypot_arr[RES_MAX_VAL] = {0};

#define FLOATLEN        (32)

static char data_buff[FLOATLEN] = {0};


/* Function to error check TFU operation  */
static fsp_err_t TFU_verification(void);
static void print_array(float arr[], uint8_t size);

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {RESET_VALUE};

    /* Version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    while(1)
    {

        /* Get desired number of steps around the unit circle from user through JLink RTT Viewer and verify input is within valid range */
        uint8_t input_res = 0;

        APP_PRINT("\r\n\nEnter desired resolution for iterating through unit circle. Input Range: %d to %d\r\n", RES_MIN_VAL, RES_MAX_VAL);
        uint8_t is_not_valid = true;

        while(is_not_valid)
        {
            if(APP_CHECK_DATA)
            {
                uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                APP_READ(readBuff);
                input_res = (uint8_t) atoi ((char*) readBuff);

                if(input_res >= RES_MIN_VAL && input_res <= RES_MAX_VAL )
                {
                   is_not_valid = false;
                }
                else
                {
                   APP_PRINT("\r\nValue out of bounds. Please enter desired resolution in range: %d to %d\r\n", RES_MIN_VAL, RES_MAX_VAL);
                }
            }

        }
        APP_PRINT("%d samples per unit circle selected.\n", input_res);


        /* Iterate through steps on unit circle and run TFU functions */

        float rad_i = 0.0;
        for(int i=0; i<input_res; ++i)
        {
            /* Calculate the next unit circle step in radians */
            rad_i = (M_TWOPI)*( (float) i /input_res) ;

            /* Calculate sine, cosine, arctangent, and hypotenuse using the in-line BSP functions */
            sine_arr[i] = sinf(rad_i);
            err = TFU_verification();
            if (FSP_SUCCESS != err)
            {   /* sinf TFU function failed */
                APP_ERR_PRINT("\r\n\n ** Invalid input for sine operation ** \r\n");
                APP_ERR_TRAP(err);
            }

            cos_arr[i] = cosf(rad_i);
            err = TFU_verification();
            if (FSP_SUCCESS != err)
            {   /* cosf TFU function failed */
                APP_ERR_PRINT("\r\n\n ** Invalid input for cosine operation ** \r\n");
                APP_ERR_TRAP(err);
            }

            atan_arr[i] = atan2f(sine_arr[i], cos_arr[i]);
            err = TFU_verification();
            if (FSP_SUCCESS != err)
            {   /* arctan2f TFU function failed */
                APP_ERR_PRINT("\r\n\n ** Invalid input for arctangent operation ** \r\n");
                APP_ERR_TRAP(err);
            }

            hypot_arr[i] = hypotf(cos_arr[i], sine_arr[i]);
            err = TFU_verification();
            if (FSP_SUCCESS != err)
            {   /* hypotf TFU function failed */
                APP_ERR_PRINT("\r\n\n ** Invalid input for hypotenuse operation ** \r\n");
                APP_ERR_TRAP(err);
            }
        }

        /* Print the contents of the arrays to RTT Viewer in CSV format */
        APP_PRINT("\r\nPrinting Sine Results:\n");
        print_array(sine_arr, input_res);

        APP_PRINT("\r\n\nPrinting Cosine Results:\n");
        print_array(cos_arr, input_res);

        APP_PRINT("\r\n\nPrinting Arctangent Results:\n");
        print_array(atan_arr, input_res);

        APP_PRINT("\r\n\nPrinting Hypotenuse Results:\n");
        print_array(hypot_arr, input_res);

    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif

}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif


/* Function to check for TFU operation errors */
static fsp_err_t TFU_verification(void){

    /* Check the value of the Input Error Flag (ERRF) in the Trigonometric Status Register (TRGSTS) to see if an input error occurred */
    if( ((R_TFU_TRGSTS & ERRF_MASK) >> 1) == 0)
    {
        return FSP_SUCCESS;
    }

    return FSP_ERR_ASSERTION;

}

/* Function to print floats to RTT Viewer using a string buffer */
static void print_array(float arr[], uint8_t size){
    for(int i=0; i<size; ++i)
    {
        snprintf(data_buff, sizeof(data_buff), "%f", arr[i]);
        APP_PRINT("%s, ", data_buff);
        /* Delay for RTT Viewer print to keep up */
        R_BSP_SoftwareDelay (30, BSP_DELAY_UNITS_MICROSECONDS);
    }
}
