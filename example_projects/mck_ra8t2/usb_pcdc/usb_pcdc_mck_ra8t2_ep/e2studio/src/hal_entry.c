/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2025 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include <stdio.h>
#include <string.h>
#include "hal_entry.h"
#include "common_init.h"

/* Global variables */
extern uint8_t g_apl_device[];
extern uint8_t g_apl_configuration[];
extern uint8_t g_apl_hs_configuration[];
extern uint8_t g_apl_qualifier_descriptor[];
extern uint8_t *g_apl_string_table[];
extern int g_curr_led_freq;

const usb_descriptor_t usb_descriptor =
{
 g_apl_device,                   /* Pointer to the device descriptor */
 g_apl_configuration,            /* Pointer to the configuration descriptor for Full-Speed */
 g_apl_hs_configuration,         /* Pointer to the configuration descriptor for Hi-Speed */
 g_apl_qualifier_descriptor,     /* Pointer to the qualifier descriptor */
 g_apl_string_table,             /* Pointer to the string descriptor table */
 NUM_STRING_DESCRIPTOR
};

usb_status_t            usb_event;

/* Banner info */
uint8_t p_welcome[200] = {
                       "\r\nWelcome to Quick Start BLINKY example project for "
                       KIT_NAME_MACRO
                       "!"
                       "\r\nPress 1 for Kit information or 2 for Next steps.\r\n"
};

/* Next steps */
uint8_t nextsteps[USB_EP_PACKET_SIZE] = {
                                      "\r\n2. Next steps\r\n"
                                      "\r\nVisit the following URLs to learn about the kit "
                                      "and the RA family of MCUs, download tools "
                                      "and documentation, and get support:\r\n"
                                      "\r\na) "
                                      KIT_NAME_MACRO
                                      " resources: \t"
                                      KIT_LANDING_URL
                                      "\r\nb) RA product information: \t"
                                      PRODUCT_INFO_URL
                                      "\r\nc) RA product support forum: \t"
                                      PRODUCT_SUPPORT_URL
                                      "\r\nd) Renesas support: \t\t"
                                      RENESAS_SUPPORT_URL
                                      "\r\n\r\nPress 1 for Kit information or 2 for next steps.\r\n"
};

uint8_t kitinfo[USB_EP_PACKET_SIZE] = {'\0'};

const uint8_t *gp_mcu_temp = (uint8_t*) "\r\nd) MCU die temperature (F/C): ";
const uint8_t *gp_led_freq = (uint8_t*) "\r\nc) Current blinking frequency (Hz): ";
const uint8_t *gp_kit_menu_ret = (uint8_t*) "\r\nPress 1 for Kit information or 2 for next steps.\r\n";

static bool  b_usb_attach = false;
static bool  g_usb_write_complete = false;

/* Private functions */
static fsp_err_t print_to_console(char *p_data);
static void process_kit_info(void);
void handle_usb_command(uint8_t user_input);

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)

{
    fsp_err_t err = FSP_SUCCESS;
    usb_event_info_t event_info = {0};
    uint8_t g_buf[READ_BUF_SIZE] = {0};
    static usb_pcdc_linecoding_t g_line_coding;

    /* Initialize GPT, ICU, ADC modules */
    if (FSP_SUCCESS != common_init())
    {
        /* Turn ON red LED to indicate fatal error */
        TURN_RED_ON
        APP_ERR_TRAP(1);
    }

    /* Open USB instance */
    err = R_USB_Open(&g_basic0_ctrl, &g_basic0_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* Turn ON red LED to indicate fatal error */
        TURN_RED_ON
        APP_ERR_TRAP(err);
    }

    while (true)
    {
        /* Obtain USB related events */
        err = R_USB_EventGet(&event_info, &usb_event);

        /* Handle error */
        if (FSP_SUCCESS != err)
        {
            /* Turn ON red LED to indicate fatal error */
            TURN_RED_ON
            APP_ERR_TRAP(err);
        }

        /* USB event received by R_USB_EventGet */
        switch (usb_event)
        {
            case USB_STATUS_CONFIGURED:
            {
                err = R_USB_Read(&g_basic0_ctrl, g_buf, READ_BUF_SIZE, USB_CLASS_PCDC);
                /* Handle error */
                if (FSP_SUCCESS != err)
                {
                    /* Turn ON red LED to indicate fatal error */
                    TURN_RED_ON
                    APP_ERR_TRAP(err);
                }

                g_usb_write_complete = true;
                break;
            }

            case USB_STATUS_READ_COMPLETE:
            {
                if (b_usb_attach)
                {
                    err = R_USB_Read(&g_basic0_ctrl, g_buf, READ_BUF_SIZE, USB_CLASS_PCDC);
                }
                /* Handle error */
                if (FSP_SUCCESS != err)
                {
                    /* Turn ON red LED to indicate fatal error */
                    TURN_RED_ON
                    APP_ERR_TRAP(err);
                }
                break;
            }

            case USB_STATUS_REQUEST: /* Receive class request */
            {
                /* Check for the specific CDC class request IDs */
                if (USB_PCDC_SET_LINE_CODING == (event_info.setup.request_type & USB_BREQUEST))
                {
                    err = R_USB_PeriControlDataGet(&g_basic0_ctrl, (uint8_t *) &g_line_coding, LINE_CODING_LENGTH);
                    /* Handle error */
                    if (FSP_SUCCESS != err)
                    {
                        /* Turn ON red LED to indicate fatal error */
                        TURN_RED_ON
                        APP_ERR_TRAP(err);
                    }
                }
                else if (USB_PCDC_GET_LINE_CODING == (event_info.setup.request_type & USB_BREQUEST))
                {
                    err = R_USB_PeriControlDataSet(&g_basic0_ctrl, (uint8_t *) &g_line_coding, LINE_CODING_LENGTH);
                    /* Handle error */
                    if (FSP_SUCCESS != err)
                    {
                        /* Turn ON red LED to indicate fatal error */
                        TURN_RED_ON
                        APP_ERR_TRAP(err);
                    }
                }
                else if (USB_PCDC_SET_CONTROL_LINE_STATE == (event_info.setup.request_type & USB_BREQUEST))
                {
                    err = R_USB_PeriControlStatusSet(&g_basic0_ctrl, USB_SETUP_STATUS_ACK);
                    /* Handle error */
                    if (FSP_SUCCESS != err)
                    {
                        /* Turn ON red LED to indicate fatal error */
                        TURN_RED_ON
                        APP_ERR_TRAP(err);
                    }
                }
                else
                {
                    /* Do nothing */
                }

                break;
            }

            case USB_STATUS_WRITE_COMPLETE:
            {
                /* USB is ready for new write operations */
                g_usb_write_complete = true;
                break;
            }

            case USB_STATUS_DETACH:
            case USB_STATUS_SUSPEND:
            {
                b_usb_attach = false;
                memset(g_buf, 0, sizeof(g_buf));
                break;
            }
            case USB_STATUS_RESUME:
            {
                b_usb_attach = true;
                break;
            }
            default:
            {
                break;
            }
        }

        /* Check if the USB is ready for writing */
        if (g_usb_write_complete)
        {
            /* Handle user input */
            handle_usb_command(g_buf[0]);
            memset(g_buf, 0, sizeof(g_buf));
        }
    }

    /* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief     This function is called to perform USB actions based on the input command.
 * @param[in] user_input The input received from the user.
 * @retval    None.
 **********************************************************************************************************************/
void handle_usb_command(uint8_t user_input)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Switch case evaluation of user input */
    switch (user_input)
    {
        case KIT_INFO:
        {
            process_kit_info();
            break;
        }
        case NEXT_STEPS:
        {
            err = print_to_console((char*)nextsteps);
            if (FSP_SUCCESS != err)
            {
                /* Turn ON RED LED to indicate fatal error */
                TURN_RED_ON
                APP_ERR_TRAP(err);
            }
            break;
        }

        case CARRIAGE_RETURN:
        {
            /* Print banner info to console */
            err = print_to_console((char*)p_welcome);
            if (FSP_SUCCESS != err)
            {
                /* Turn ON RED LED to indicate fatal error */
                TURN_RED_ON
                APP_ERR_TRAP(err);
            }
            break;
        }

        default:
        {
            break;
        }
    }
}

/*******************************************************************************************************************//**
 *  @brief      This function prints the message to console.
 *  @param[in]  p_data          Contains address of buffer to be printed.
 *  @retval     FSP_SUCCESS     Upon success.
 *  @retval     Any other error code apart from FSP_SUCCESS, write is unsuccessful.
 **********************************************************************************************************************/
static fsp_err_t print_to_console(char *p_data)
{
    fsp_err_t err = FSP_SUCCESS;
    uint32_t len = ((uint32_t)strlen(p_data));

    /* Clear ready flag for USB write in progress */
    g_usb_write_complete = false;
    err = R_USB_Write(&g_basic0_ctrl, (uint8_t*)p_data, len, USB_CLASS_PCDC);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    return err;
}

/*******************************************************************************************************************//**
 *  @brief      Process kit information.
 *  @param[in]  None.
 *  @retval     None.
 **********************************************************************************************************************/
static void process_kit_info(void)
{
    uint16_t buffer_index_count = 0x0000;
    uint16_t adc_data           = 0;
    float mcu_temp_f            = 0;
    float mcu_temp_c            = 0;
    fsp_err_t err = FSP_SUCCESS;

#if !(BSP_PERIPHERAL_ADC_B_PRESENT)
    /* Start ADC scan again in Single scan mode */
    if (ADC_MODE_SINGLE_SCAN == g_adc_cfg.mode)
    {
        err = R_ADC_ScanStart(&g_adc_ctrl);
        /* Handle error */
        if (FSP_SUCCESS != err)
        {
            print_to_console("** R_ADC_ScanStart API failed **\r\n");
            /* Turn ON RED LED to indicate fatal error */
            TURN_RED_ON
            APP_ERR_TRAP(err);
        }
    }
#endif

    /* Read die temperature */
#if (BSP_PERIPHERAL_ADC_B_PRESENT)
    err = R_ADC_B_Read(&g_adc_b_ctrl, ADC_CHANNEL_TEMPERATURE, &adc_data);
#else
    err = R_ADC_Read(&g_adc_ctrl, ADC_CHANNEL_TEMPERATURE, &adc_data);
#endif /* BSP_PERIPHERAL_ADC_B_PRESENT */
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        print_to_console("** R_"ADC_TYPE"_Read API failed **\r\n");
        /* Turn ON red LED to indicate fatal error */
        TURN_RED_ON
        APP_ERR_TRAP(err);
    }

    /* Conversion ADC temperature in Fahrenheit */
    mcu_temp_f = ADCTEMP_AS_F(adc_data);
    /* Conversion ADC temperature in Celsius */
    mcu_temp_c = ADCTEMP_AS_C(adc_data);

    /* Clear kit info buffer before updating data */
    memset(kitinfo, '\0', 511);

    /* Update predefined text in the buffer */
    memcpy(kitinfo, (char *)KIT_INFO_PRIMARY_TEXT, strlen((char *)KIT_INFO_PRIMARY_TEXT));

    /* Calculate current data filled length */
    buffer_index_count = ((uint16_t)(strlen((char*)kitinfo)));

    /* Check for current led frequency */
    if (BLINK_FREQ_1HZ == g_curr_led_freq)
    {
        sprintf((char*)&kitinfo[buffer_index_count],"%s\t%d",gp_led_freq,1);
    }
    else if (BLINK_FREQ_5HZ == g_curr_led_freq)
    {
        sprintf((char*)&kitinfo[buffer_index_count],"%s\t%d",gp_led_freq,5);
    }
    else if (BLINK_FREQ_10HZ == g_curr_led_freq)
    {
        sprintf((char*)&kitinfo[buffer_index_count],"%s\t%d",gp_led_freq,10);
    }
    else
    {
        /* Do nothing */
    }

    buffer_index_count = 0U;

    /* Kit_processing_data is filled with led frequency details */
    buffer_index_count = ((uint16_t)(strlen((char*)kitinfo)));

    /* Appends the data from current buffer_index_count */
    sprintf((char *)&kitinfo[buffer_index_count],
            "%s\t\t%.02f/%.02f",gp_mcu_temp,mcu_temp_f,mcu_temp_c);

    buffer_index_count = 0U;

    /* Update index count */
    buffer_index_count = ((uint16_t) (strlen((char*)kitinfo)));

    /* Update index count */
    sprintf((char*)&kitinfo[buffer_index_count],"\r\n%s",gp_kit_menu_ret);

    /* Print kit menu to console */
    err = print_to_console((char*)kitinfo);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* Turn ON red LED to indicate fatal error */
        TURN_RED_ON
        APP_ERR_TRAP(err);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 * @} (end addtogroup hal_entry)
 **********************************************************************************************************************/
