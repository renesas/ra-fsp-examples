#include "hal_data.h"
#include "ospi_b_ep.h"
#include "ospi_b_commands.h"
#include "common_utils.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Global variables */

/* Function declarations*/
void handle_error(fsp_err_t err,  const char *err_str);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t           err                         = FSP_SUCCESS;
    fsp_pack_version_t  version                     = {RESET_VALUE};
    uint32_t            flash_id                    = RESET_VALUE;
    uint8_t             rtt_read[BUFFER_SIZE_DOWN]  = {RESET_VALUE};
    uint8_t             * p_ospi_b_address           = NULL;

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT_WAIT;
    APP_PRINT(EP_INFO);
    APP_PRINT_WAIT;

    /* Initialize timer to measure OSPI operation */
    err = timer_init();
    handle_error(err, "timer_init FAILED\r\n");

    /* Initialize OSPI driver module and Flash device in SPI mode */
    err = ospi_b_init();
    handle_error(err, "ospi_b_init FAILED\r\n");

    /* Read Flash device ID */
    err = ospi_b_read_device_id(&flash_id);
    handle_error(err, "ospi_b_read_device_id FAILED\r\n");

    /* Print flash device ID */
    APP_PRINT("\r\nDevice ID read successfully");
    APP_PRINT("\r\nManufacturer ID = 0x%x, Memory Interface Type = 0x%x, Density = 0x%x\r\n",
                (uint8_t)flash_id, (uint8_t)(flash_id >> 8), (uint8_t)(flash_id >> 16));

    /* Print Main Menu option */
    APP_PRINT(MAIN_MENU);

    /* Main Loop */
    while(true)
    {
        /* Check new input data from RTT */
        if(APP_CHECK_DATA)
        {
            /* Clean RTT input buffer */
            memset(rtt_read, RTT_NULL_CHAR, BUFFER_SIZE_DOWN);
            APP_READ(rtt_read);

            /* Handle Main Menu */
            switch(rtt_read[RTT_CHECK_INDEX])
            {
                /* Select SPI mode */
                case RTT_SELECT_SPI_MODE_CHAR:
                {
                    /* Set OSPI to SPI mode */
                    err = ospi_b_set_protocol_to_spi();
                    handle_error(err, "ospi_b_set_protocol_to_spi FAILED\r\n");

                    /* Set pointer to flash device memory for SPI operation */
                    p_ospi_b_address = OSPI_B_APP_ADDRESS(OSPI_B_SECTOR_FIRST);

                    /* Perform OSPI operations */
                    err = ospi_b_operation(p_ospi_b_address);
                    handle_error(err, "ospi_b_operation FAILED\r\n");
                    break;
                }

                /* Select DOPI mode */
                case RTT_SELECT_OPI_MODE_CHAR:
                {
                    /* Set OSPI to OPI mode */
                    err = ospi_b_set_protocol_to_opi();
                    handle_error(err, "ospi_b_set_protocol_to_opi FAILED\r\n");

                    /* Set pointer to flash device memory for OPI operation */
                    p_ospi_b_address = OSPI_B_APP_ADDRESS(OSPI_B_SECTOR_SECOND);

                    /* Perform OSPI operations */
                    err = ospi_b_operation(p_ospi_b_address);
                    handle_error(err, "ospi_b_operation FAILED\r\n");
                    break;
                }

                /* Invalid input */
                default:
                {
                    APP_PRINT ("\r\nInvalid input. Provide a valid input\r\n");
                    break;
                }
            }

            /* Print Main Menu option of OSPI operation.*/
            APP_PRINT(MAIN_MENU);
        }
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

/*******************************************************************************************************************//**
 *  @brief       This function handle error if error occurred, closes all opened module, print and traps error.
 *  @param[in]   status    error status
 *  @param[in]   err_str   error string
 *  @retval      None
 **********************************************************************************************************************/
void handle_error(fsp_err_t err,  const char *err_str)
{
    if(FSP_SUCCESS != err)
    {
        /* Print the error */
        APP_PRINT(err_str);

        /* Close opened OSPI module*/
        if(0U != g_ospi_b_ctrl.open)
        {
            if(FSP_SUCCESS != R_OSPI_B_Close(&g_ospi_b_ctrl))
            {
                APP_ERR_PRINT("R_OSPI_B_Close FAILED\r\n");
            }
        }

        /* Close opened GPT module*/
        if(0U != g_timer_ctrl.open)
        {
            if(FSP_SUCCESS != R_GPT_Close(&g_timer_ctrl))
            {
                APP_ERR_PRINT("R_GPT_Close FAILED\r\n");
            }
        }

        /* Trap the error */
        APP_ERR_TRAP(err);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
