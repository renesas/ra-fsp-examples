/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
* Copyright (c) 2020 - 2025 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "common_utils.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * @addtogroup DOC_NS_EP
 * @{
 **********************************************************************************************************************/
/** Macros **/
/* To write the first data to doc register for subtraction event */
#define DOC_DATA_SUB                 (0xA5A4)
/* To write the second data to doc register for subtraction event */
#define DOC_DATA_UNDERFLOW           (0x0002)
/* To write the first data to doc register for addition event */
#define DOC_DATA_ADD                 (0X5A5A)
/* To write the second data to doc register for addition event to overflow */
#define DOC_DATA_OVERFLOW            (0x0001)
/* To write the data to doc register for comparison match event */
#define DOC_DATA_COMPARISON_MATCH    (0xA5A5)
/* To write the data to doc register for comparison mismatch event */
#define DOC_DATA_COMPARISON_MISMATCH (0xB5B5)

static void doc_deinit(void);

/** Global Variables **/
static bool b_doc_event_flag = false;           /* Event counter updates for every callback triggers */
extern bsp_leds_t g_bsp_leds;                   /* LED Structure used to blink on board LED */

/* The 2 following prototypes for custom guard function can be removed in future */
fsp_err_t led_set_guard (bsp_io_port_pin_t pin, bsp_io_level_t level);
doc_event_t doc_cfg_event_read_guard (void);

doc_callback_args_t g_doc_callback_args;
void doc_callback(doc_callback_args_t *p_args);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used. This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void) {
    fsp_pack_version_t version = {RESET_VALUE};
    fsp_err_t err              = FSP_SUCCESS;
    /* Version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Example Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major,\
            version.version_id_b.minor, version.version_id_b.patch);

    APP_PRINT("\r\nThe example project demonstrates the typical use of the DOC HAL module APIs."
            "\r\nThe project performs the different event operations selected by the user in"
            "\r\nconfigurator properties. Events can be selected viz., Compare Match, Compare Mismatch,"
            "\r\nAddition Overflow, Subtraction Underflow. Upon Success/Failure of operation,"
            "\r\nthe result will be displayed on RTT Viewer. LED will turn ON only if the selected"
            "\r\nevent operation is success and stays OFF if the operation fails.\r\n");

    /* Initialize the DOC module for Comparison/Addition/Subtraction Operations with Initial
     * value written in DOC Data Setting Register
     * Note:
     *     Arguments are passed in as NULL since the guard functions will ignore them.
     *     The guard functions are generated in the secure project doc_s_ek_ra6m4_ep/src/g_doc_guard.c */
    err = g_doc_open_guard (NULL, NULL);
    /* Handle Error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** g_doc_open_guard API failed **");
        APP_ERR_TRAP(err);
    }

    err = g_doc_callback_set_guard(NULL, doc_callback, NULL, &g_doc_callback_args);
    /* Handle Error */
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n** g_doc_callback_set_guard API failed **");
        APP_ERR_TRAP(err);
    }

    /* Write the predefined data to doc register, depends on the selected event operations will take place */
    switch (doc_cfg_event_read_guard ())
    {
        case DOC_EVENT_COMPARISON_MISMATCH:
            APP_PRINT("\r\nSelected event is Comparison MisMatch");
            /* Write mismatch to the DOC Data Input Register */
            err = g_doc_write_guard (NULL, DOC_DATA_COMPARISON_MISMATCH);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit ();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_COMPARISON_MATCH:
            APP_PRINT("\r\nSelected event is Comparison Match");
            /* Write match data to the DOC Data Input Register */
            err = g_doc_write_guard (NULL, DOC_DATA_COMPARISON_MATCH);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit ();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_ADDITION:
            APP_PRINT("\r\nSelected event is Addition Overflow");
            /* Write first data to the DOC Data Input Register */
            err = g_doc_write_guard (NULL, DOC_DATA_ADD);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit ();
                APP_ERR_TRAP(err);
            }
            /* Write second data to the DOC Data Input Register to occur overflow event */
            err = g_doc_write_guard(NULL, DOC_DATA_OVERFLOW);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit ();
                APP_ERR_TRAP(err);
            }
            break;

        case DOC_EVENT_SUBTRACTION:
            APP_PRINT("\r\nSelected event is Subtraction Underflow");
            /* Write first data to the DOC Data Input Register */
            err = g_doc_write_guard (NULL, DOC_DATA_SUB);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            /* Write second data to the DOC Data Input Register to occur underflow event */
            err = g_doc_write_guard (NULL, DOC_DATA_UNDERFLOW);
            /* Handle Error */
            if (FSP_SUCCESS != err)
            {
                APP_ERR_PRINT("\r\n** g_doc_write_guard API failed **");
                doc_deinit();
                APP_ERR_TRAP(err);
            }
            break;
        default: break;
    }

     /* Prints the RTT message when interrupt occurs upon successful event operations */
    if (true == b_doc_event_flag)
    {
        b_doc_event_flag = false;   /* RESET flag */
        APP_PRINT("\r\nDOC operation is successful for the selected event");
        /* Turn ON LED to indicate callback triggered, along with output on RTT */
#if defined (BOARD_RA8T1_MCK)
        led_set_guard((bsp_io_port_pin_t)g_bsp_leds.p_leds[0], BSP_IO_LEVEL_LOW);
#else
        led_set_guard((bsp_io_port_pin_t)g_bsp_leds.p_leds[0], BSP_IO_LEVEL_HIGH);
#endif
    }
    else
    {
        APP_PRINT("\r\nDOC operation failed for the selected event");
    }
    APP_PRINT("\r\nRestart the application to rerun the code");
    while (true)
    {
        ; /* Do nothing */
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * @brief       Based on the selected event in the configurator. The doc call back will occur for the selected
 *              event when operations are performed with the reference data.
  * @param[in]  p_args
 * @return      None
 **********************************************************************************************************************/
void doc_callback(doc_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    /* Set the event flag */
    b_doc_event_flag = true;
}

/*******************************************************************************************************************//**
 * @brief       This function is to de-initializes the DOC module
 * @param[in]   None
 * @return      None
 **********************************************************************************************************************/
static void doc_deinit(void)
{
    fsp_err_t err = FSP_SUCCESS;
    err = g_doc_close_guard (NULL);
    if (FSP_SUCCESS != err)
    {
        APP_ERR_PRINT("\r\n**g_doc_close_guard API failed**");
        APP_ERR_TRAP(err);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process. This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take
         * more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build
 * (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

/*******************************************************************************************************************//**
 * @} (end defgroup DOC_NS_EP)
 **********************************************************************************************************************/
