/**********************************************************************************************************************
 * Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *********************************************************************************************************************/
#include "hal_data.h"
#include "common_utils.h"

#define bool _Bool

/* Number of samples to convert continuously before halting capture. */
#define NUM_SAMPLES (1024)

/* Conversion values of ADC signal acquisition */
static volatile int32_t adc16_vals[NUM_SAMPLES] = { 0 };
static volatile uint16_t user_input;
static volatile uint16_t sample_iter = 0;
static volatile bool b_scan_in_progress = false;

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

static void calibration_procedure(void);
static void cleanup_procedure(void);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{

    volatile fsp_err_t err = FSP_SUCCESS;
    volatile bool b_first_run = true;
    volatile bool b_no_input = true;

    /* Initialize the module, enable channels, and calibrate ADC */
    err = R_ADC_B_Open(&g_adc_16bit_ctrl, &g_adc_16bit_cfg);
    if (FSP_SUCCESS != err)
    { /* ADC module open failed */
        APP_ERR_PRINT("\r\n ** ADC Open API failed ** \r\n");
        APP_ERR_TRAP(err);
    }

    err = R_ADC_B_ScanCfg(&g_adc_16bit_ctrl, &g_adc_16bit_scan_cfg);
    if (FSP_SUCCESS != err)
    { /* ADC module scan configuration failed */
        APP_ERR_PRINT("\r\n ** ADC ScanCfg API failed ** \r\n");
        APP_ERR_TRAP(err);
    }

    /* Loop begins */
    while (1)
    {
        /* ADC Calibration needs to occur after initial ADC setup on the first run. */
        if (b_first_run)
        {
            calibration_procedure();
            b_first_run = false;
        }
        /* ADC Calibration also needs to occur on subsequent runs if conditions require it. Poll user to see if required. */
        else
        {
            b_no_input = true;
            APP_PRINT("If conditions changed since last conversion and conditions meet the requirements for re-calibration, enter '3' on keyboard.\n If not, to skip re-calibration enter '4'.\r\n ");
            while (b_no_input)
            {
                if (APP_CHECK_DATA)
                {
                    uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                    APP_READ(readBuff);
                    user_input = (uint16_t) atoi((char*) readBuff);

                    if (user_input == 3)
                    {
                        calibration_procedure();
                        b_no_input = false;
                    }
                    else if (user_input == 4)
                    {
                        APP_PRINT("\r\nSkipping re-calibration...\r\n\n");
                        b_no_input = false;
                    }
                }
            }
        }

        /* Wait for user input to begin the continuous conversion. */
        APP_PRINT("ADC is ready for conversion to begin.\r\n ");
        APP_PRINT("Enter '1' on the keyboard to begin conversion.\r\n\n");

        b_no_input = true;

        while (b_no_input)
        {
            if (APP_CHECK_DATA)
            {
                uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                APP_READ(readBuff);
                user_input = (uint16_t) atoi((char*) readBuff);

                if (user_input == 1)
                {
                    b_no_input = false;
                }
            }
        }

        APP_PRINT("ADC conversion started...\r\n\n");

        /* Start all scan groups of ADC0 */
        err = R_ADC_B_ScanGroupStart(&g_adc_16bit_ctrl, ADC_GROUP_MASK_0);
        if (FSP_SUCCESS != err)
        { /* ADC module scan group start failed */
            APP_ERR_PRINT("\r\n ** ADC ScanGroupStart API failed ** \r\n");
            APP_ERR_TRAP(err);
        }

        b_scan_in_progress = true;

        while (b_scan_in_progress);

        /* Wait so users can export array or observe values, if needed. To restart the program, press any button on keyboard. */
        APP_PRINT("ADC conversion completed. If desired, pause the program now to view and/or export conversion values. \r\n");
        APP_PRINT("Once you are ready to restart program, enter '2' on the keyboard. \r\n\n");

        b_no_input = true;
        while (b_no_input)
        {
            if (APP_CHECK_DATA)
            {
                uint8_t readBuff[BUFFER_SIZE_DOWN] = { RESET_VALUE };
                APP_READ(readBuff);
                user_input = (uint16_t) atoi((char*) readBuff);

                if (user_input == 2)
                {
                    b_no_input = false;
                }
            }
        }

        APP_PRINT("Program is restarting...\r\n\n");

        /* Restart cleanup procedure: Clear the adc values in adc16_vals[], stop the adc*/
        cleanup_procedure();

    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

void calibration_procedure(void)
{
    fsp_err_t err = FSP_SUCCESS;
    APP_PRINT("\r\nCalibrating ADC...\r\n");

    err = R_ADC_B_Calibrate(&g_adc_16bit_ctrl, NULL);
    if (FSP_SUCCESS != err)
    { /* ADC module calibrate failed */
        APP_ERR_PRINT("\r\n ** ADC Calibrate API failed ** \r\n");
        APP_ERR_TRAP(err);
    }

    adc_status_t status = {
                            .state = ADC_STATE_SCAN_IN_PROGRESS
    };
    while ((ADC_STATE_SCAN_IN_PROGRESS == status.state) && (FSP_SUCCESS == err))
    {
        R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);
        err = R_ADC_B_StatusGet(&g_adc_16bit_ctrl, &status);
    }
    assert(FSP_SUCCESS == err);
    APP_PRINT("ADC successfully calibrated.\r\n\n");

}

void cleanup_procedure(void)
{
    fsp_err_t err = FSP_SUCCESS;
    for (int i = 0; i < NUM_SAMPLES; ++i)
    {
        adc16_vals[i] = 0;
    }

    err = R_ADC_B_ScanStop(&g_adc_16bit_ctrl);
    if (FSP_SUCCESS != err)
    { /* ADC module scan stop failed */
        APP_ERR_PRINT("\r\n ** ADC ScanStop API failed ** \r\n");
        APP_ERR_TRAP(err);
    }
    sample_iter = 0;
}

void cb_scan_end(adc_callback_args_t *p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);

    if (sample_iter >= NUM_SAMPLES)
    {
        b_scan_in_progress = false;
    }
    else
    {

        /* Read result and store in converted values array. */
        fsp_err_t err = FSP_SUCCESS;
        uint16_t channel_0_conversion_result;
        err = R_ADC_B_Read(&g_adc_16bit_ctrl, ADC_CHANNEL_0, &channel_0_conversion_result);
        if (FSP_SUCCESS != err)
        { /* ADC module read failed */
            APP_ERR_PRINT("\r\n ** ADC Read API failed ** \r\n");
            APP_ERR_TRAP(err);
        }

        adc16_vals[sample_iter] = (int32_t) channel_0_conversion_result;
        ++sample_iter;
    }
}
